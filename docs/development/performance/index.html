<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Performance and Efficiency Research# As part of my learning journey, I wanted to understand the performance profile of Lynx FIM. Security tools must be efficient; if an agent consumes too much CPU or takes too long to hash files, it won’t be used in production.
1. Hashing Throughput (SHA-256)# I ran benchmarks using Go’s standard crypto/sha256 library to see how fast we can process file data.
Benchmark Results (August 2025)# File Size Time per Operation Estimated Throughput 1 MB ~0.64 ms ~1.5 GB/s 10 MB ~6.48 ms ~1.5 GB/s My Observation: Go’s implementation of SHA-256 is incredibly fast. This confirms that Lynx can handle even large configuration or binary files without significant latency.
"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://ItsAdam01.github.io/Lynx/docs/development/performance/"><meta property="og:site_name" content="Lynx FIM Documentation"><meta property="og:title" content="Performance Analysis"><meta property="og:description" content="Performance and Efficiency Research# As part of my learning journey, I wanted to understand the performance profile of Lynx FIM. Security tools must be efficient; if an agent consumes too much CPU or takes too long to hash files, it won’t be used in production.
1. Hashing Throughput (SHA-256)# I ran benchmarks using Go’s standard crypto/sha256 library to see how fast we can process file data.
Benchmark Results (August 2025)# File Size Time per Operation Estimated Throughput 1 MB ~0.64 ms ~1.5 GB/s 10 MB ~6.48 ms ~1.5 GB/s My Observation: Go’s implementation of SHA-256 is incredibly fast. This confirms that Lynx can handle even large configuration or binary files without significant latency."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta itemprop=name content="Performance Analysis"><meta itemprop=description content="Performance and Efficiency Research# As part of my learning journey, I wanted to understand the performance profile of Lynx FIM. Security tools must be efficient; if an agent consumes too much CPU or takes too long to hash files, it won’t be used in production.
1. Hashing Throughput (SHA-256)# I ran benchmarks using Go’s standard crypto/sha256 library to see how fast we can process file data.
Benchmark Results (August 2025)# File Size Time per Operation Estimated Throughput 1 MB ~0.64 ms ~1.5 GB/s 10 MB ~6.48 ms ~1.5 GB/s My Observation: Go’s implementation of SHA-256 is incredibly fast. This confirms that Lynx can handle even large configuration or binary files without significant latency."><meta itemprop=wordCount content="616"><title>Performance Analysis | Lynx FIM Documentation</title><link rel=icon href=/Lynx/favicon.png><link rel=manifest href=/Lynx/manifest.json><link rel=canonical href=https://ItsAdam01.github.io/Lynx/docs/development/performance/><link rel=stylesheet href=/Lynx/book.min.cc2c524ed250aac81b23d1f4af87344917b325208841feca0968fe450f570575.css integrity="sha256-zCxSTtJQqsgbI9H0r4c0SRezJSCIQf7KCWj+RQ9XBXU=" crossorigin=anonymous><script defer src=/Lynx/fuse.min.js></script><script defer src=/Lynx/en.search.min.a3decc09741295e7b8e0634c1bf86f3f3ee6f07f338b11d9bc2ea2d65e329232.js integrity="sha256-o97MCXQSlee44GNMG/hvPz7m8H8zixHZvC6i1l4ykjI=" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-docs"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/Lynx/><span>Lynx FIM Documentation</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/Lynx/docs/usage/installation/>Installation & Setup</a></li><li><a href=/Lynx/docs/usage/features/>General Features</a></li><li><a href=/Lynx/docs/development/requirements/>Requirements</a></li><li><a href=/Lynx/docs/usage/commands/>Command Reference</a></li><li><a href=/Lynx/docs/development/technical_specs/>Technical Specifications</a></li><li><a href=/Lynx/docs/development/implementation_plan/>Implementation Plan</a></li><li><a href=/Lynx/docs/usage/isolated_testing/>Isolated Lab Testing (Experimental)</a></li><li><a href=/Lynx/docs/development/implementation_story/>Implementation Story</a></li><li><a href=/Lynx/docs/development/demonstration/>Demonstration & Proof of Concept</a></li><li><a href=/Lynx/docs/development/performance/ class=active>Performance Analysis</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/Lynx/icons/menu.svg class=book-icon alt=Menu></label><h3>Performance Analysis</h3><label for=toc-control><img src=/Lynx/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#1-hashing-throughput-sha-256>1. Hashing Throughput (SHA-256)</a><ul><li><a href=#benchmark-results-august-2025>Benchmark Results (August 2025)</a></li></ul></li><li><a href=#2-baseline-generation-speed>2. Baseline Generation Speed</a><ul><li><a href=#result>Result:</a></li></ul></li><li><a href=#3-real-time-monitoring-overhead>3. Real-time Monitoring Overhead</a></li><li><a href=#4-complexity-analysis-big-o>4. Complexity Analysis (Big O)</a><ul><li><a href=#phase-1-initial-baselining>Phase 1: Initial Baselining</a></li><li><a href=#phase-2-real-time-monitoring>Phase 2: Real-time Monitoring</a></li></ul></li><li><a href=#5-portability-and-static-compilation>5. Portability and Static Compilation</a><ul><li><a href=#targeting-distributions-vs-architectures>Targeting Distributions vs. Architectures</a></li><li><a href=#cicd-automation>CI/CD Automation</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=performance-and-efficiency-research>Performance and Efficiency Research<a class=anchor href=#performance-and-efficiency-research>#</a></h1><p>As part of my learning journey, I wanted to understand the performance profile of Lynx FIM. Security tools must be efficient; if an agent consumes too much CPU or takes too long to hash files, it won&rsquo;t be used in production.</p><h2 id=1-hashing-throughput-sha-256>1. Hashing Throughput (SHA-256)<a class=anchor href=#1-hashing-throughput-sha-256>#</a></h2><p>I ran benchmarks using Go&rsquo;s standard <code>crypto/sha256</code> library to see how fast we can process file data.</p><h3 id=benchmark-results-august-2025>Benchmark Results (August 2025)<a class=anchor href=#benchmark-results-august-2025>#</a></h3><table><thead><tr><th>File Size</th><th>Time per Operation</th><th>Estimated Throughput</th></tr></thead><tbody><tr><td>1 MB</td><td>~0.64 ms</td><td>~1.5 GB/s</td></tr><tr><td>10 MB</td><td>~6.48 ms</td><td>~1.5 GB/s</td></tr></tbody></table><p><strong>My Observation:</strong> Go&rsquo;s implementation of SHA-256 is incredibly fast. This confirms that Lynx can handle even large configuration or binary files without significant latency.</p><h2 id=2-baseline-generation-speed>2. Baseline Generation Speed<a class=anchor href=#2-baseline-generation-speed>#</a></h2><p>I also benchmarked the coordination logic—scanning the file system, calculating hashes, and signing the output.</p><h3 id=result>Result:<a class=anchor href=#result>#</a></h3><ul><li><strong>100 Files:</strong> ~1.28 ms total.</li></ul><p><strong>My Observation:</strong> The overhead of the file system walker and the HMAC signing is negligible. For most standard server directories (like <code>/etc/</code>), establishing a baseline should take less than a second.</p><h2 id=3-real-time-monitoring-overhead>3. Real-time Monitoring Overhead<a class=anchor href=#3-real-time-monitoring-overhead>#</a></h2><p>While harder to benchmark precisely without specialized tools, my manual testing with <code>fsnotify</code> showed:</p><ul><li><strong>CPU Usage:</strong> Near 0% while idling.</li><li><strong>Memory:</strong> Minimal (under 20MB) even when watching several hundred files.</li></ul><p>This efficiency is due to using Linux <code>inotify</code> hooks rather than polling the disk. It allows the agent to stay &ldquo;asleep&rdquo; until the kernel notifies it of an event.</p><h2 id=4-complexity-analysis-big-o>4. Complexity Analysis (Big O)<a class=anchor href=#4-complexity-analysis-big-o>#</a></h2><p>To ensure Lynx can scale to larger systems, I&rsquo;ve analyzed the theoretical complexity of its core algorithms.</p><h3 id=phase-1-initial-baselining>Phase 1: Initial Baselining<a class=anchor href=#phase-1-initial-baselining>#</a></h3><p>This is the &ldquo;Heavy Lifting&rdquo; phase where the agent established the Source of Truth.</p><ul><li><strong>Time Complexity:</strong> <span class=book-katex>\( O(N \cdot S) \)</span><link rel=stylesheet href=/Lynx/katex/katex.min.css><script defer src=/Lynx/katex/katex.min.js></script><script defer src=/Lynx/katex/auto-render.min.js onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script><ul><li><span class=book-katex>\( N \)</span> = Number of files.</li><li><span class=book-katex>\( S \)</span> = Average size of the files.</li><li>The agent must walk the directory tree (<span class=book-katex>\( O(N) \)</span>) and then read every byte of every file to calculate the SHA-256 hash (<span class=book-katex>\( O(S) \)</span> per file).</li></ul></li><li><strong>Space Complexity:</strong> <span class=book-katex>\( O(N \cdot P) \)</span><ul><li><span class=book-katex>\( P \)</span> = Average length of the file path string.</li><li>The agent stores a map of file paths to their corresponding hashes. This map grows linearly with the number of files being monitored.</li></ul></li></ul><h3 id=phase-2-real-time-monitoring>Phase 2: Real-time Monitoring<a class=anchor href=#phase-2-real-time-monitoring>#</a></h3><p>This is the &ldquo;Idle Defense&rdquo; phase where the agent waits for events.</p><ul><li><strong>Time Complexity:</strong> <span class=book-katex>\( O(S_{changed}) \)</span><ul><li>Detection is <span class=book-katex>\( O(1) \)</span> because the Linux kernel pushes events to the agent (no polling required).</li><li>When an event occurs, the agent only re-hashes the <strong>specific file</strong> that changed. This takes <span class=book-katex>\( O(S) \)</span> where <span class=book-katex>\( S \)</span> is the size of that modified file. Comparison with the in-memory baseline is a map lookup, which is <span class=book-katex>\( O(1) \)</span> on average.</li></ul></li><li><strong>Space Complexity:</strong> <span class=book-katex>\( O(N \cdot P) \)</span><ul><li>The agent maintains the full baseline in memory to allow for instant comparisons when a file event is received.</li></ul></li></ul><h2 id=5-portability-and-static-compilation>5. Portability and Static Compilation<a class=anchor href=#5-portability-and-static-compilation>#</a></h2><p>One of the biggest wins I discovered during this project is Go&rsquo;s approach to compilation.</p><h3 id=targeting-distributions-vs-architectures>Targeting Distributions vs. Architectures<a class=anchor href=#targeting-distributions-vs-architectures>#</a></h3><p>I initially wondered if I needed to build separate versions for Ubuntu, CentOS, and Debian. My research taught me that because Go produces <strong>statically linked binaries</strong> (especially with <code>CGO_ENABLED=0</code>), the agent includes all the libraries it needs to run.</p><p>This means a single binary built for <code>linux-amd64</code> will run on almost any modern Linux distribution without requiring any dependencies (like Python or GLIBC) to be installed on the target server.</p><h3 id=cicd-automation>CI/CD Automation<a class=anchor href=#cicd-automation>#</a></h3><p>I&rsquo;ve implemented a GitHub Actions workflow to automate this process. Every time I push code, the system:</p><ol><li>Runs all unit tests to ensure no regressions.</li><li>Cross-compiles the binary for both <strong>AMD64</strong> (Standard Servers) and <strong>ARM64</strong> (AWS Graviton / Raspberry Pi).</li><li>Uploads the finished binaries as build artifacts.</li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/Lynx/docs/development/demonstration/ class="flex align-center"><img src=/Lynx/icons/backward.svg class=book-icon alt=Backward>
<span>Demonstration & Proof of Concept</span>
</a></span><span></span></div><div class=book-comments></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-hashing-throughput-sha-256>1. Hashing Throughput (SHA-256)</a><ul><li><a href=#benchmark-results-august-2025>Benchmark Results (August 2025)</a></li></ul></li><li><a href=#2-baseline-generation-speed>2. Baseline Generation Speed</a><ul><li><a href=#result>Result:</a></li></ul></li><li><a href=#3-real-time-monitoring-overhead>3. Real-time Monitoring Overhead</a></li><li><a href=#4-complexity-analysis-big-o>4. Complexity Analysis (Big O)</a><ul><li><a href=#phase-1-initial-baselining>Phase 1: Initial Baselining</a></li><li><a href=#phase-2-real-time-monitoring>Phase 2: Real-time Monitoring</a></li></ul></li><li><a href=#5-portability-and-static-compilation>5. Portability and Static Compilation</a><ul><li><a href=#targeting-distributions-vs-architectures>Targeting Distributions vs. Architectures</a></li><li><a href=#cicd-automation>CI/CD Automation</a></li></ul></li></ul></nav></div></aside></main></body></html>